# ViewPoint: Единая Точка Обзора

Этот документ описывает класс `ViewPoint` — один из ключевых элементов нашего WebGPU-движка. Он представляет собой реализацию нашего основного архитектурного принципа: **упрощение API через осмысленное объединение связанных сущностей.**

## Философия и Дизайн

В большинстве 3D-движков, включая `three.js`, камера (`Camera`) и управление ею (`Controls`) являются раздельными объектами. Такой подход гибок, но для стандартных случаев приводит к написанию повторяющегося кода.

Мы придерживаемся иного подхода. `ViewPoint` — это целостная сущность, представляющая **точку обзора пользователя в 3D-мире.** Она изначально интерактивна и объединяет в себе логику перспективной проекции и орбитального управления.

### Контракт через Параметры

Одним из ключевых аспектов нашего API является использование **объектов-параметров**. Вместо длинного списка аргументов в конструкторе, `ViewPoint` принимает один объект `ViewPointParameters`.

**Хорошо:**
```typescript
const viewPoint = new ViewPoint({
    element: renderer.canvas,
    fov: 1,
    position: { x: 0, y: 0, z: 10 }
});
```

**Плохо:**
```typescript
const viewPoint = new ViewPoint(renderer.canvas, 1, 0.1, 1000, new Vector3(0, 0, 10), ...);
```

Этот подход, который мы называем "контрактом", делает код самодокументируемым (имена параметров видны в месте вызова) и упрощает добавление новых опций в будущем без нарушения обратной совместимости.

## Контракт Системы Координат: RH_ZO

Фундаментальным архитектурным решением движка является строгий **контракт системы координат**, известный как **RH_ZO**. Это соглашение определяет, как мы интерпретируем пространство и преобразования на всех уровнях, от математических библиотек до кода шейдеров.

*   **RH (Right-Handed, Правосторонняя):** Мы используем правую систему координат (Z-up).

    *   **+X** указывает **вправо**.

    *   **+Y** указывает **вглубь**.

    *   **+Z** указывает **вверх**.
    Это интуитивно понятная система, часто используемая в 3D-моделировании (например, в Blender).

*   **ZO (Zero-to-One, От Нуля до Единицы):** Пространство отсечения (Clip Space) использует диапазон глубины **[0, 1]**.
    *   **Ближняя** плоскость отсечения (`near`) соответствует значению **Z = 0**.
    *   **Дальняя** плоскость отсечения (`far`) соответствует значению **Z = 1**.
    Это является стандартом для современных графических API, включая **WebGPU** (а также Vulkan и Metal), в отличие от OpenGL, который использует диапазон `[-1, 1]`.

Соблюдение этого контракта во всем движке гарантирует предсказуемость матричных преобразований и упрощает отладку, так как все компоненты "говорят на одном языке".

## Управление "Из Коробки": Логика и Реализация

`ViewPoint` обеспечивает интуитивное кросс-платформенное управление. Ниже описаны механики и их реализация.

### Мышь

| Действие | Ввод пользователя | Техническая реализация |
| :--- | :--- | :--- |
| **Вращение** | Зажать **левую кнопку** и двигать | **Trackball-вращение**. В отличие от простого вращения вокруг осей X и Y, этот метод использует **кватернионы**. Это позволяет избежать проблемы "складывания" осей (Gimbal Lock) при взгляде на полюса, обеспечивая плавное вращение в любом направлении, как при вращении трекбола. |
| **Панорамирование**| Зажать **правую кнопку** и двигать | Перемещение камеры в плоскости экрана. Сдвиг происходит вдоль векторов "вправо" и "вверх" самой камеры, извлеченных из матрицы вида. |
| **Панорамирование**| **Прокрутка колесиком** | То же, что и панорамирование правой кнопкой, но для осей X и Y. Удобно для быстрой навигации. |
| **Масштаб** | **`Ctrl` + Прокрутка колесиком** | **Динамический зум**. Скорость масштабирования зависит от текущего расстояния до цели, обеспечивая плавное и предсказуемое приближение/отдаление как вблизи, так и вдали от объекта. |

### Тач-устройства (Смартфоны, Планшеты)

Логика касаний спроектирована так, чтобы быть интуитивной и избегать конфликтов с жестами браузера (`touch-action: "none"`).

| Действие | Ввод пользователя | Техническая реализация |
| :--- | :--- | :--- |
| **Вращение** | Двигать **одним пальцем** | Аналогично вращению мышью (Trackball). |
| **Панорамирование и Масштаб** | Двигать **двумя пальцами** | Обрабатываются одновременно. **Жест "щипок"** (изменение расстояния между пальцами) управляет масштабом. **Перемещение** центральной точки между пальцами управляет панорамированием. Для интуитивности панорамирование инвертировано, создавая эффект "перетаскивания мира". |

### Тачпады (Ноутбуки)

Современные тачпады распознаются браузером как события `wheel`, что позволяет реализовать управление, похожее на нативное.

| Действие | Ввод пользователя | Техническая реализация |
| :--- | :--- | :--- |
| **Панорамирование**| Смахивать **двумя пальцами** | Генерирует события `wheel` без нажатого `Ctrl`. `ViewPoint` использует `event.deltaX` и `event.deltaY` для панорамирования. |
| **Масштаб** | Жест **"щипок"** (Pinch-to-Zoom) | Генерирует события `wheel` **с нажатым `Ctrl`**. `ViewPoint` распознает это как команду масштабирования. |
| **Вращение** | Двигать **одним пальцем** (с нажатием) | Распознается как стандартное событие мыши (левая кнопка). |

## Пример Использования

Сравните простоту нашего подхода с традиционным:

```typescript
// 1. Импортируем все необходимое
import { ViewPoint, WebGPURenderer, Scene } from "../src/WebGPUEngine"

// 2. Создаем рендерер и сцену
const renderer = new WebGPURenderer()
await renderer.init()
// Логика обработки DPI инкапсулирована в рендерере.
// Просто вызываем setSize с логическими размерами.
renderer.setSize(window.innerWidth, window.innerHeight)
const scene = new Scene()

// 3. Создаем ViewPoint, используя новый контракт
const viewPoint = new ViewPoint({
    element: renderer.canvas!,
    aspect: window.innerWidth / window.innerHeight,
})

// 4. Используем viewPoint в цикле рендеринга
function animate() {
    renderer.render(scene, viewPoint)
    requestAnimationFrame(animate)
}

animate()
```

Как видите, код становится чище, а намерение — яснее. Мы создаем "точку обзора" и передаем ее в рендерер. Все остальное просто работает.

## API и Документация

Подробное описание всех параметров конструктора (`ViewPointParameters`) и публичных методов класса находится непосредственно в TSDoc-комментариях в файле `src/core/ViewPoint.ts`. Мы придерживаемся принципа самодокументируемого кода, поэтому исходный код является самым достоверным источником информации об API.

## Планы на Будущее (TODO)

Класс `ViewPoint` является фундаментом, на котором можно строить более сложные функции. Вот некоторые идеи для дальнейшего развития:

### Общие улучшения
*   **[ ] Плавное затухание (Damping/Inertia):** Добавить эффект инерции для более плавного и естественного замедления вращения и панорамирования после того, как пользователь отпустил кнопку мыши.
*   **[ ] Программные анимации:** Реализовать методы для кинематографических перемещений камеры, такие как `flyTo(targetPosition)` или `panTo(newCenter)`.
*   **[ ] Переключение режимов управления:** Добавить возможность менять режим управления, например, с `Orbit` на `First-Person` или `Turntable`.
*   **[ ] Ограничения осей:** Ввести опции для блокировки вращения или панорамирования по определенным осям (например, разрешить только горизонтальное вращение).
*   **[ ] Динамическое изменение центра вращения:** Добавить метод для программной установки новой точки, вокруг которой будет вращаться камера (например, по клику на объект).

### Улучшения для устройств
*   **[ ] Настройка чувствительности:** Добавить параметры для настройки скорости вращения, масштабирования и панорамирования отдельно для мыши, тачпада и сенсорного экрана.
*   **[ ] Поддержка геймпадов:** Интегрировать Gamepad API для управления камерой с помощью джойстиков.
*   **[ ] Расширенные жесты:** Реализовать поддержку более сложных жестов, например, вращение двумя пальцами (twist) для поворота камеры вокруг оси вида.
*   **[ ] Интеграция с WebXR:** Расширить `ViewPoint` для работы в качестве камеры в VR/AR сессиях, используя WebXR Device API. Это потребует получения матриц проекции и вида от XR-устройства.
