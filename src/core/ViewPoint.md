# ViewPoint: Единая Точка Обзора

Этот документ описывает класс `ViewPoint` — один из ключевых элементов нашего WebGPU-движка. Он представляет собой реализацию нашего основного архитектурного принципа: **упрощение API через осмысленное объединение связанных сущностей.**

## Философия и Дизайн

В большинстве 3D-движков, включая `three.js`, камера (`Camera`) и управление ею (`Controls`) являются раздельными объектами. Разработчику необходимо:

1.  Создать экземпляр камеры (например, `PerspectiveCamera`).
2.  Создать экземпляр элемента управления (например, `OrbitControls`).
3.  Связать их вместе, передав камеру в конструктор управления.
4.  Не забывать вызывать `controls.update()` в каждом кадре анимационного цикла.

Такой подход гибок, но для 80% стандартных случаев он избыточен и приводит к написанию повторяющегося кода. 

Мы придерживаемся иного подхода. `ViewPoint` — это не просто "камера". Это целостная сущность, представляющая **точку обзора пользователя в 3D-мире.** Она изначально интерактивна и знает, как реагировать на действия пользователя, независимо от устройства ввода.

**Наше решение:** `ViewPoint` объединяет в себе логику перспективной проекции и интерактивного управления. Разработчику достаточно создать один объект и передать его в рендерер. Никаких ручных связываний и вызовов `update()` не требуется.

## Разделение Ответственности: Логические Размеры и DPI

Еще один пример нашего стремления к упрощению API — это обработка размеров экрана и плотности пикселей (DPI).

*   **`ViewPoint`** оперирует **логическими размерами** (`window.innerWidth` / `window.innerHeight`). Его задача — знать соотношение сторон (`aspect`) для корректного построения матрицы проекции. Ему не важна физическая плотность пикселей на дисплее.

*   **`WebGPURenderer`** также принимает на вход логические размеры, но берет на себя ответственность за **работу с DPI** (`devicePixelRatio`). Он автоматически вычисляет необходимый физический размер холста (`canvas`), умножая логические размеры на DPI.

**Что это дает?**

Разработчику не нужно писать стандартный код для определения DPI и передавать его в рендерер. Движок "из коробки" обеспечивает кристально четкое изображение на любых экранах (включая Retina), сохраняя при этом API чистым и простым. Вы просто задаете размеры, а `ViewPoint` и `WebGPURenderer` грамотно распределяют обязанности.

## Кросс-платформенное Управление "Из Коробки"

`ViewPoint` спроектирован для интуитивной работы на самых разных устройствах без дополнительной настройки. Панорамирование реализовано по принципу "перемещения камеры", а не "перетаскивания мира": движение мыши или пальцев по экрану смещает точку обзора в том же направлении, что обеспечивает интуитивное управление как в современных 3D-редакторах.

Внутренняя логика класса автоматически определяет и обрабатывает события от мыши, тачпада и тачскрина.

| Устройство | Действие | Ввод пользователя |
| :--- | :--- | :--- |
| **Десктоп (Мышь)** | Вращение | Зажать **левую кнопку** и двигать |
| | Панорамирование | Зажать **правую кнопку** и двигать |
| | Масштабирование | **Прокрутка колесиком** |
| **Ноутбук (Тачпад)**| Вращение | Двигать **одним пальцем** |
| | Панорамирование | Смахивать **двумя пальцами** |
| | Масштабирование | Жест **"щипок"** (Pinch-to-Zoom) |
| **Мобильные (Тачскрин)**| Вращение | Двигать **одним пальцем** (Touch & Move) |
| | Панорамирование | Смахивать **двумя пальцами** |
| | Масштабирование | Жест **"щипок"** |

### Как это работает?

Класс содержит внутренние обработчики событий, которые анализируют не только тип события (`mousedown`, `wheel`, `touchmove`), но и его свойства (`event.button`, `event.deltaX`, `event.ctrlKey`, `event.deltaMode`). Это позволяет, например, точно отличить жест "щипок" от свайпа двумя пальцами на тачпаде, что решает проблему конфликта жестов и делает управление более предсказуемым.

## Пример Использования

Сравните простоту нашего подхода с традиционным:

```typescript
// 1. Импортируем все необходимое
import { ViewPoint, WebGPURenderer, Scene } from "../src/WebGPUEngine"

// 2. Создаем рендерер и сцену
const renderer = new WebGPURenderer()
await renderer.init()
// Логика обработки DPI инкапсулирована в рендерере.
// Просто вызываем setSize с логическими размерами.
renderer.setSize(window.innerWidth, window.innerHeight)
const scene = new Scene()

// 3. Создаем ViewPoint, ему нужны только логические размеры для aspect
const viewPoint = new ViewPoint({
    element: renderer.canvas!,
    aspect: window.innerWidth / window.innerHeight,
})

// 4. Используем viewPoint в цикле рендеринга
function animate() {
    renderer.render(scene, viewPoint)
    requestAnimationFrame(animate)
}

animate()
```

Как видите, код становится чище, а намерение — яснее. Мы создаем "точку обзора" и передаем ее в рендерер. Все остальное просто работает.

## API и Документация

Подробное описание всех параметров конструктора (`ViewPointParameters`) и публичных методов класса находится непосредственно в TSDoc-комментариях в файле `src/core/ViewPoint.ts`. Мы придерживаемся принципа самодокументируемого кода, поэтому исходный код является самым достоверным источником информации об API.

## Планы на Будущее (TODO)

Класс `ViewPoint` является фундаментом, на котором можно строить более сложные функции. Вот некоторые идеи для дальнейшего развития:

### Общие улучшения
*   **[ ] Плавное затухание (Damping/Inertia):** Добавить эффект инерции для более плавного и естественного замедления вращения и панорамирования после того, как пользователь отпустил кнопку мыши.
*   **[ ] Программные анимации:** Реализовать методы для кинематографических перемещений камеры, такие как `flyTo(targetPosition)` или `panTo(newCenter)`.
*   **[ ] Переключение режимов управления:** Добавить возможность менять режим управления, например, с `Orbit` на `First-Person` или `Turntable`.
*   **[ ] Ограничения осей:** Ввести опции для блокировки вращения или панорамирования по определенным осям (например, разрешить только горизонтальное вращение).
*   **[ ] Динамическое изменение центра вращения:** Добавить метод для программной установки новой точки, вокруг которой будет вращаться камера (например, по клику на объект).

### Улучшения для устройств
*   **[ ] Настройка чувствительности:** Добавить параметры для настройки скорости вращения, масштабирования и панорамирования отдельно для мыши, тачпада и сенсорного экрана.
*   **[ ] Поддержка геймпадов:** Интегрировать Gamepad API для управления камерой с помощью джойстиков.
*   **[ ] Расширенные жесты:** Реализовать поддержку более сложных жестов, например, вращение двумя пальцами (twist) для поворота камеры вокруг оси вида.
*   **[ ] Интеграция с WebXR:** Расширить `ViewPoint` для работы в качестве камеры в VR/AR сессиях, используя WebXR Device API. Это потребует получения матриц проекции и вида от XR-устройства.
