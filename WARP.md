# WARP.md

This file provides guidance to WARP (warp.dev) when working with code in this repository.

## Язык и стиль кода

- Весь код, комментарии, документация и сообщения об ошибках пишутся **на русском языке**.
- Проект использует **TypeScript**. Все экспортируемые классы, интерфейсы и методы должны иметь **TSDoc**‑комментарии.
- Именование: `camelCase` для переменных и функций, `PascalCase` для классов и интерфейсов. Файлы с классами обычно называются в `PascalCase`.
- В конце выражений **не используются точки с запятой**. Форматирование следует принятым настройкам (предпочтительно через Biome или эквивалент).
- Для конструкторов и функций с несколькими параметрами (особенно с необязательными) используется **один объект‑параметр**, а не длинный список аргументов.
- При проверке входных данных в публичных API при ошибке выбрасывается `Error` с понятным сообщением на русском.

Полная версия правил для ИИ и стиля кода находится в `.idx/airules.md`. При неочевидных решениях опирайтесь сначала на этот файл.

## Инструменты и основные команды

Проект основан на **Bun** и разворачивается на **Firebase Hosting**.

### Зависимости и типизация

- Установка зависимостей: `bun install`
- Проверка типов (TypeScript, без генерации файлов): `bun run typecheck`

### Локальная разработка

- Основная точка входа фронтенда: `index.html`, который подключает `examples/main.ts`.
- Для разработки используется встроенный dev‑сервер Bun с HMR:
  - Скрипт: `bun run dev` (обёртка над `bun --hot ./index.html`).
  - В соответствии с правилами из `.idx/airules.md` dev‑сервер следует считать **всегда запущенным**. Не предлагайте запускать его по собственной инициативе; выполняйте эту команду только по явному запросу пользователя.

Есть также файл `serve.ts`, который поднимает Bun‑сервер с маршрутом на `index.html` (порт берётся из `PORT` или 3000). Им можно пользоваться для кастомных сценариев, но основной рабочий путь для разработки — `bun run dev`.

### Сборка приложения

- Продакшн‑сборка SPA: `bun run build`
- Результат сборки: каталог `dist/`
- Firebase Hosting target для основного приложения: `app` (см. `firebase.json`).

Деплой на Firebase должен выполняться только по явному запросу пользователя (например, "задеплой сайт"). При необходимости деплоя опирайтесь на `firebase.json` и используйте `dist/` как публичную папку для таргета `app`.

### Документация

Документация генерируется с помощью **TypeDoc**.

- Генерация API‑документации: `bun run build:docs`
- Конфигурация: `typedoc.json` (точка входа `./src`, стратегия `expand`, выходная папка `docs/`).
- Firebase Hosting target для документации: `docs` (см. `firebase.json`).

Как и для основного приложения, генерация и деплой документации выполняются **только по явному запросу** пользователя.

### Тесты

В проекте на данный момент **нет настроенного набора автоматических тестов и соответствующих npm/Bun‑скриптов**. Если потребуется добавить тестирование, предварительно согласуйте выбор инструмента (Vitest/Jest и т.п.) и структуру тестов с пользователем.

## Высокоуровневая архитектура

Архитектура движка вдохновлена `three.js`: есть граф сцены, геометрии, материалы, рендерер и вспомогательное математическое ядро. Однако проект намеренно упрощён и ориентирован на WebGPU.

### Публичный API движка

Файл `src/WebGPUEngine.ts` — это **баррель‑модуль**, который реэкспортирует основные сущности движка:

- базовые классы сцены (`Object3D`, `Scene`),
- геометрии (`BufferGeometry`, `TorusGeometry` и др.),
- материалы (`MeshBasicMaterial`, агрегатор `Materials`),
- камеру и управление (`ViewPoint`),
- рендерер (`WebGPURenderer`),
- загрузчик моделей (`GLTFLoader`),
- утилитарные типы и математику (`Color` и др.).

Примеры и прикладной код должны импортировать API **только** из `src/WebGPUEngine.ts`, а не из внутренних путей, чтобы сохранить стабильный внешний контракт.

### Граф сцены и объекты

- `core/Object3D.ts` — базовый класс для всех сущностей сцены.
  - Хранит позицию, вращение (как углы Эйлера и кватернион), масштаб, локальную матрицу `modelMatrix`, флаг `visible` и массив `children`.
  - Метод `updateMatrix()` собирает локальную матрицу из позиции, вращения и масштаба.
- `scenes/Scene.ts` расширяет `Object3D`, добавляя тип `Scene` и свойство `background: Color`. Сам `Scene` тоже является корнем графа.
- `core/Mesh.ts` наследуется от `Object3D` и добавляет связку **геометрия + материал(ы)**. Это основная отрисовываемая сущность.
- В `objects/` находятся дополнительные примитивы (`Line`, `LineSegments`), построенные поверх `Object3D`/`BufferGeometry`.

Всю иерархию объектов (меши, линии, подузлы glTF‑сцены и т.п.) следует строить через добавление дочерних `Object3D`/`Mesh` в `Scene` или другие узлы графа.

### Геометрия и материалы

- `core/BufferGeometry.ts` и `core/BufferAttribute.ts` задают структуру данных для вершинных атрибутов и индексов (аналогично `BufferGeometry` в `three.js`).
- `geometries/TorusGeometry.ts` — пример конкретной геометрии (тор), использующий параметрический объект‑параметры по правилам из `.idx/airules.md`.
- `materials/Material.ts` — базовый класс материала с общими полями (например, флаг `visible`).
- `materials/MeshBasicMaterial.ts` — простой материал без освещения, который задаёт цвет (`Color`) и видимость. Сейчас это основной материал, который реально используется WebGPU‑шейдером.
- `materials/Materials.ts` агрегирует и реэкспортирует материалы для удобного импорта через баррель `WebGPUEngine.ts`.
- Математическое ядро (`math/Color.ts`, `Vector3.ts`, `Quaternion.ts`, `Matrix4.ts`) реализует минимальный набор типов для работы с векторами, кватернионами, матрицами и цветами.

Расширяя движок (новые геометрии/материалы), придерживайтесь существующей схемы: параметрические интерфейсы, TSDoc на русском, использование базовых типов из `math/`.

### Камера и управление: ViewPoint

`core/ViewPoint.ts` реализует ключевой архитектурный принцип движка: **объединение камеры и управления** в единый класс.

- `ViewPoint` инкапсулирует параметры перспективной камеры (FOV, aspect, near/far, позиция) и всю логику пользовательского ввода.
- Класс работает с **логическими размерами** окна (например, `window.innerWidth/innerHeight`), отвечая только за корректный `aspect` и матрицу проекции.
- Управление кросс‑платформенное "из коробки": мышь, тачпад, тач‑жесты (вращение, панорамирование, масштаб).
- Детальная философия и поведение описаны в `src/core/ViewPoint.md` и TSDoc внутри `ViewPoint.ts`. При изменениях API обязательно сверяйтесь с этими документами.

### Рендерер WebGPU

`renderers/WebGPURenderer.ts` отвечает за полный цикл рендеринга на WebGPU:

- Инициализация WebGPU: проверка `navigator.gpu`, выбор адаптера и устройства, создание `canvas` и контекста `webgpu`.
- Конфигурация `GPUCanvasContext` и создание рендер‑пайплайна (шейдеры, layout, мультисэмплинг, depth‑текстура). Шейдер сейчас жёстко встроен строкой в метод `getShaderCode()` и ожидает один позиционный атрибут и цвет из uniform‑буфера.
- Управление global‑uniform (матрица вида‑проекции) и per‑object‑uniform буферами с динамическими оффсетами (рассчитано на ограниченное количество объектов в кадре).
- Кеширование GPU‑буферов геометрии в `geometryCache` по экземпляру `BufferGeometry`.
- Метод `render(scene, viewPoint)`:
  - обновляет размер depth/multisample‑текстур под текущий размер `canvas`;
  - записывает матрицу `viewProjection` (`projectionMatrix * viewMatrix` из `ViewPoint`) в global‑uniform;
  - обходит граф сцены рекурсивно (`collectRenderables`), собирая видимые `Mesh` и их мировые матрицы;
  - для каждого меша записывает в per‑object‑uniform мировую матрицу и цвет материала (если `MeshBasicMaterial`), привязывает вершинный/индексный буферы и вызывает `draw`/`drawIndexed`.

Таким образом, рендерер ожидает, что:

- все `Object3D` корректно обновляют свою `modelMatrix` (через `updateMatrix()` или прямую установку для glTF‑узлов),
- `Scene.background` задаёт цвет очистки кадра,
- `ViewPoint` предоставляет актуальные `viewMatrix` и `projectionMatrix`.

### Загрузчик GLTF и примеры

- `loaders/GLTFLoader.ts` реализует базовую поддержку формата glTF 2.0:
  - загружает JSON‑описание, связанные бинарные буферы и материалы,
  - строит дерево `Object3D`, маппируя glTF‑узлы в иерархию `Object3D`/`Mesh`,
  - создаёт `BufferGeometry` и `BufferAttribute` из accessor/bufferView,
  - создаёт `MeshBasicMaterial` на основе `pbrMetallicRoughness.baseColorFactor`.
- API `GLTFLoader.load(url)` возвращает `{ scene: Scene }`, что удобно для последующего `rootScene.add(gltf.scene)`.

Главный пример использования движка находится в `examples/main.ts`:

- Инициализируется `WebGPURenderer`, создаётся `Scene` и `ViewPoint`.
- Подписка на `resize` обновляет размер рендерера и aspect‑ratio `ViewPoint`.
- Через `GLTFLoader` загружается удалённая glTF‑модель и добавляется в сцену.
- В `requestAnimationFrame`‑цикле вызывается `renderer.render(scene, viewPoint)`.

`index.html` просто подключает этот модуль как `<script type="module" src="./examples/main.ts"></script>` и задаёт базовые стили для полноэкранного канваса.

## Как использовать эти знания в будущих задачах

- При добавлении новых возможностей сначала определите, в какой слой они попадают: **математика**, **геометрии**, **материалы**, **граф сцены**, **рендерер**, **загрузчики** или **пример/приложение**. Старайтесь не смешивать уровни.
- Поддерживайте баррель `src/WebGPUEngine.ts` в актуальном состоянии: любые новые публичные сущности, которые предназначены для использования снаружи, должны экспортироваться оттуда.
- Новые примеры и демо‑страницы лучше строить по образцу `examples/main.ts`, импортируя API из `WebGPUEngine.ts` и работая через `ViewPoint` + `WebGPURenderer`.
- Перед мержем нетипичных изменений (новый формат загрузки, переработка шейдера, изменение принципов работы ViewPoint) имеет смысл обновить или дополнить `ViewPoint.md`, `.idx/airules.md` и при необходимости `README.md`, чтобы сохранить консистентность архитектурного описания.